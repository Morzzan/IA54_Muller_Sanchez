/** 
 * 
 */
package behaviors

import com.vividsolutions.jts.geom.Coordinate
import com.vividsolutions.jts.geom.Geometry
import com.vividsolutions.jts.geom.GeometryFactory
import com.vividsolutions.jts.operation.distance.DistanceOp
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import java.util.concurrent.Semaphore
import model.DiscoveredEvent
import model.HelpMe
import model.PerceptEvent
import model.ShareExploredZoneEvent
import model.SurvivorSaved
import model.Utils
import model.Vector3D
import skillscapacities.MoveCapacity

/** 
 * @author morzzan
 * 
 */
behavior SearchBehavior {
	var unexplored : Geometry
	val lock = new Semaphore(0)
	uses Logging, MoveCapacity, DefaultContextInteractions, Behaviors

	on Initialize {
		unexplored = occurrence.parameters.get(0) as Geometry
		lock.release
	}

	on PerceptEvent {
		addPercept(occurrence)
		updateUnexploredZone
		for (uav : occurrence.around) {
			lock.acquire
			emit(new ShareExploredZoneEvent(unexplored))[it.UUID == uav.id]
			lock.release
		}
		lock.acquire
		if (unexplored.area > 0) {
			lock.release
			moveTo(makeExplorationStrategy)
		} else {
			lock.release
			moveRandomly
		}
	}

	on ShareExploredZoneEvent {
		lock.acquire
		unexplored = unexplored.intersection(occurrence.zone)
		lock.release
	}

	on HelpMe {
		val l = newArrayList
		l.add(occurrence.survivor)
		emit(new DiscoveredEvent(l))[it.UUID == this.owner.ID]
		unregisterBehavior(this)
	}
		
	on SurvivorSaved {
		emit(new DiscoveredEvent(occurrence.survivors))[it.UUID == this.owner.ID]
		unregisterBehavior(this)
	}

	def updateUnexploredZone {
		val pos = currentPercept.pos
		val myGeom = Utils.createCircle(Utils.perceptRadius, new Coordinate(pos.x, pos.y))
		lock.acquire
		unexplored = unexplored.difference(myGeom)
		lock.release
	}

	def makeExplorationStrategy {
		val currentPercept = currentPercept
		var r : Vector3D
		val p = new GeometryFactory().createPoint((currentPercept.pos.add(currentPercept.speed).toPlaneCoordinate))
		try {
			lock.acquire
			val op = new DistanceOp(unexplored, p)
			r = new Vector3D(op.nearestPoints.get(0))
			lock.release
		} catch (e : Exception) {
			r = new Vector3D
		}
		return r
	}
}
