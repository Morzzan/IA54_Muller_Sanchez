/** 
 * 
 */
package skillscapacities

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Logging
import java.util.concurrent.Semaphore
import model.GoThatWay
import model.PerceptEvent
import model.Vector3D

/** 
 * @author morzzan
 * 
 */
skill MoveSkill implements MoveCapacity {
	uses DefaultContextInteractions, Logging
	val lock = new Semaphore(1)
	var percept : PerceptEvent = new PerceptEvent(new Vector3D,new Vector3D,newArrayList,true)
	
	override getCurrentPercept : PerceptEvent{
		lock.acquire
		try return new PerceptEvent(percept.pos,percept.speed, percept.around,percept.onZone)
		finally lock.release
	}
		
	override addPercept(p : PerceptEvent){
		lock.acquire
		percept=p
		lock.release
	}
	override move(direction : Vector3D) {
		var d = direction.add(separation)
		emit(new GoThatWay(d.stayOnZone))
	}
	override moveRandomly {
		move(Vector3D.randomDirection())
	}

	override moveTo(position : Vector3D){
		move(position.substract(currentPercept.pos).unitarize)
	}
	
	def separation {
		var vSep = new Vector3D(0, 0, 0)
		if (currentPercept !== null && currentPercept.around !== null) {
			for (o : currentPercept.around) {
				var n = o.pos.add(currentPercept.pos.times(-1))
				if (n.norm === 0) {
					n = Vector3D.randomDirection
				}
				var a = n.unitarize.times(-100 / Math.pow(n.norm, 2))
				vSep = vSep.add(a)
			}
		}
		return vSep
	}
	def stayOnZone(direction : Vector3D) {
		if(currentPercept == null || currentPercept.onZone) return direction
		else{
			info("Not On Zone Anymore")
			return currentPercept.pos.times(-1)
		}
	}
}
