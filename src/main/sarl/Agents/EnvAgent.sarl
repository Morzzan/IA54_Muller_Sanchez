/** 
 * 
 */
package model

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.UUID
import view.Fx3DView
import io.sarl.core.Schedules
import java.util.concurrent.Semaphore

/** 
 * @author morzzan
 */
agent EnvAgent {
	var fx : Fx3DView
	val nbsteps = 200
	var step = 0
	val env = new Environment
	var nbuavs : int
	val uavs = <UUID, UAVBody> newHashMap
	val actions = <GoThatWay> newArrayList
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
	val sem = new Semaphore(1)

	on Initialize {
		info("The EnvAgent was started.")
		loggingName = "Env"
		nbuavs = occurrence.parameters.get(0) as Integer
	}
	on StartEvent {
		info("Received Start event")
		fx = occurrence.fx
		for (var i = 0; i < nbuavs; i++) {
			spawn(typeof(UAVAgent), i)	
		}			
	}
	on RegisterEvent{
		var bdy = new UAVBody(occurrence.source.UUID, occurrence.nb)
		uavs.put(occurrence.source.UUID,bdy)
		if(uavs.size >= nbuavs){
			sendPercepts
		}

	}
	on GoThatWay{
		sem.acquire
		actions.add(occurrence)
		if(actions.size === nbuavs){
			sem.release
			in(50)[runstep]
		}
		else sem.release
	}
	on Destroy{
		emit(new EndEvent)
	}
	
	def sendPercepts{
		for(uav : uavs.values){
			emit(new PerceptEvent(uav.pos, uav.speed ,<Vector3D>newArrayList, env.isOnZone(uav)))[it.UUID == uav.id]
		}
	}
	def getNeighbors(uav : UAVBody){
		var around = <Vector3D>newArrayList
		for(n : uavs.values){
			if(n.pos.add(uav.pos.times(-1)).norm < uav.perceptRadius && n != uav) around.add(n.pos)
		}
		return around
	}
	def runstep{
		if(step >= nbsteps) killMe
		step++
		for(action : actions){
			var actorBody = uavs.get(action.source.UUID)
			actorBody.accelerate(action.direction)
		}
		for(uav : uavs.values){
			uav.move
		}
		fx.moveUAVs(uavs.values)
		actions.clear
		sendPercepts
	}	
}
